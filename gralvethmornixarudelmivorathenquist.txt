gralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastimgralvethmornixarudelmivorathenquistralobendrixvarlumethsorvinaltreximborvethlansirduqualmirestovranhelixmorvandarithulbexronvidaltarqueminsolvarithenploxidarvenquilmarestivandorlemthariquonvexmarildustrenvokhalminarthuvexlendoribarvastomquelnirathenvodramishelquronvethmarzilondravenstipholkarimvestulnadorquenlivastremoidalvornexthimraldurvenqastilomverhundiqolmarithenstavroxilemquandarithomvexlurnidastalverquinmoralthesinvarquinvorthalmedrastonquivarlimexthuranvelmoridastrelvexhonqivarundelsthavroniqelmardusvithenqualporimendaxlurovimthardenqualvostimarhelquinvarlodexranthimarquilvenstosharminqelvarothimbrendaxurvalistomvenqrathilendurvaxmordinthalqerustimvanlidorqenstavrimhulbarthonqelvasturimdenvalqirustemlavorinthaqelvurnistomarqenhulvatherimsondraxlenvorquilmarithenstavromildarquenlithavorimqelrunstavmarithorvenduslinqavermodathilqunvoraxmelridathorquenvastilbramodexlunvarthesorqimendarvultharinexlomvarthioqelmanrithavendrosquilvarthomexlundravithorquenlastimavorthenquildomarstavenrolthimarqenlastovridamulthiqorvenlaxtrimhadoqelmivarnostelqivaromnexthurladimvorqenstavrilthorimquendelvarmoxthiravunlemqastorivunthalqermidavolnexthurvamistolqarvundexlimtharvonquilendarxomvelstrinavodermilqastorinvelthurmondexlarivunthomqeralvidustonmarquilthenvorimaxdulorvendastilqermonvaxlitherqomendravistulmarqenlodravexthonrimlaverqostimhadulvernaxqolmirevathensturqoldimbranvorathilquemdarxolonrivasthemqelbrinthavorqenludraxmirsolthaverniquemradolvinstravothilqernamivosthelbradunvexlorthimqeravilomstadurnelvaxthirumondavlexthorimistnavorqelminthavroduslixverthalmonduqirastelvornimaxthudelranqelmivorandustalrenvoxhilmarquidestovarnelbrathomivasterlungdevorhilqenmarstivornaxdulmerlavinthoqerustamivardexlunthomialvenqorusthilvermadaxlonrivelsthamoqendralvurthasnigorveltrimaxdulhernivastomqerundalvixthorimestunqalvermidastornivamlexthuronqelridamolvenstharquimaxdulovrenqiltharvendastim







l1_lex
#include <stdio.h>
#include <string.h>
#include <ctype.h>

int iskeyword (char * word){

    const char *keywords[]={
        "int","float","double","long","char","string","void",
        "if","for","while","switch","else","break","continue",
        "return","static","struct"
    };

    int n=17;
    for(int i=0;i<n;i++){
        if(strcmp(word,keywords[i])==0)
        return 1;
    }
    return 0;
}

int main(){
    char ch,buffer[100];
    int i=0;
    int tot_tokens=0,k_count=0,i_count=0,n_count=0,s_count=0;

    FILE *fp =fopen("input.c","r");
    if(!fp){
        printf("cannnot open file\n");
        return 1;
    }

    while((ch=fgetc(fp))!=EOF){
        if(isalnum(ch)|| ch=='_'){
            buffer[i++]=ch;
        }else{
            if(i!=0){
                buffer[i]='\0';
                tot_tokens++;

                if(iskeyword(buffer)) k_count++;
                else i_count++;

                i=0;
            }

            if(ispunct(ch)){
                tot_tokens++;
                s_count++;
            }
        }
    }

    fclose(fp);

    printf("%d\n",tot_tokens);
    printf("%d\n",k_count);
    printf("%d\n",i_count);
    printf("%d\n",n_count);
    printf("%d\n",s_count);

    return 0;
}



l2_lex
#include <stdio.h>
#include<string.h>
#include<ctype.h>

const char *keywords[] = {
    "int","float","double","long","char","void","if","else",
    "for","while","do","return","break","continue","switch","case","default"
};
int k_count=17;

const char *operators[] ={ "+", "-", "*", "/", "=", "==", "++", "--", "<", ">", "<=", ">=", "!=" };
int o_count=13;

const char spc_symbols[] = {'(', ')', '{', '}', ';', ',' };
int s_count=6;

int iskeyword(const char *word){
    for(int i=0;i<k_count;i++){
        if(strcmp(word,keywords[i])==0)
        return 1;
    }
    return 0;
}

int isoperator(char ch,char next){
    char temp[3]={ch,next,'\0'};

    for(int i=0;i<o_count;i++){
        if(strcmp(operators[i],temp)==0)
        return 2;
    }
    for(int i=0;i<o_count;i++){
        if(operators[i][0]==ch && operators[i][1]=='\0');
        return 1;
    }
    return 0;
}

int isspcsymbol(char ch){
    for(int i=0;i<s_count;i++){
        if(spc_symbols[i]==ch)
        return 1;
    }
    return 0;
}


int main(){
    FILE *fp=fopen("input.c","r");

    if(!fp){
        printf("cannot open file");
        return 1;
    }

    char ch,next;
    char buffer[100];
    int i=0;

    while ((ch=fgetc(fp))!=EOF){

        if( isspace(ch)) continue;

        if(isalpha(ch)|| ch=='_'){
            i=0;
            buffer[i++]=ch;
            while((ch=fgetc(fp))!=EOF && (isalnum(ch)|| ch=='_'))
            buffer[i++]=ch;

            buffer[i]='\0';
            ungetc(ch,fp);

            if(iskeyword(buffer)) printf("Keyword : %s\n",buffer);
            else printf("Identifier: %s\n",buffer);
        }

        else if(isdigit(ch)){
            i=0;
            int isFloat=0;
            buffer[i++]=ch;

            while ((ch=fgetc(fp)) !=EOF && (isdigit(ch) || ch=='.')){
                if(ch=='.'){
                    if(isFloat) break;
                    isFloat=1;
                }
                buffer[i++]=ch;
            }
            buffer[i]='\0';
            ungetc(ch,fp);

            if(isFloat) printf("Float: %s\n",buffer);
            else printf("Integer: %s",buffer);
        }

        else{

            next=fgetc(fp);
            int optype=isoperator(ch,next);

            if(optype==2){
                printf("Operator,%c%c\n",ch,next);
            }else if(optype==1){
                ungetc(next,fp);
                printf("Operator: %c\n",ch);
            }else if(isspcsymbol(ch)){
                ungetc(next,fp);
                printf("Spc symbol: %c\n",ch);
            }else {
                ungetc(next,fp);
                if(!isspace(ch)) printf("Error %c",ch);
            }
        }
    }
    fclose(fp);
    return 0;
}

l3_lex
#include <iostream>
#include <fstream>
#include <vector>
#include <regex>
#include <unordered_set>
using namespace std;

struct SymbolEntry {
    int entryNo;
    string lexeme;
    string tokenType;
    int lineDeclared;
    int lineUsed;
};

vector<SymbolEntry> symbolTable;

unordered_set<string> keywords = {
    "int", "float", "return", "if", "else", "for", "while", "void", "char", "double"
};

bool isIdentifier(const string& s) {
    return regex_match(s, regex("^[a-zA-Z_][a-zA-Z0-9_]*$")) && !keywords.count(s);
}

bool isInteger(const string& s) {
    return regex_match(s, regex("^[0-9]+$"));
}

bool isFloat(const string& s) {
    return regex_match(s, regex("^[0-9]*\\.[0-9]+$"));
}

bool isLiteral(const string& s) {
    return regex_match(s, regex("^\".*\"$"));
}

bool isOperator(char ch) {
    return string("+-*/=%").find(ch) != string::npos;
}

bool isSymbol(char ch) {
    return string("(){};,").find(ch) != string::npos;
}

void addSymbol(string lexeme, string type, int line) {
    for (auto& entry : symbolTable) {
        if (entry.lexeme == lexeme) {
            entry.lineUsed = line;
            return;
        }
    }
    symbolTable.push_back({(int)symbolTable.size() + 1, lexeme, type, line, line});
}

void processLine(const string& line, int lineNum) {
    string token;
    bool inLiteral = false;

    for (size_t i = 0; i < line.size(); ++i) {
        char ch = line[i];

        if (ch == '"') {
            if (inLiteral) {
                token += ch;
                addSymbol(token, "Literal", lineNum);
                token.clear();
                inLiteral = false;
            } else {
                token = "\"";
                inLiteral = true;
            }
            continue;
        }

        if (inLiteral) {
            token += ch;
            continue;
        }

        if (isspace(ch) || isOperator(ch) || isSymbol(ch)) {
            if (!token.empty()) {
                if (keywords.count(token)) addSymbol(token, "Keyword", lineNum);
                else if (isIdentifier(token)) addSymbol(token, "Identifier", lineNum);
                else if (isInteger(token)) addSymbol(token, "Integer", lineNum);
                else if (isFloat(token)) addSymbol(token, "Float", lineNum);
                else cout << "Error at line " << lineNum << ": " << token << "\n";
                token.clear();
            }

            if (isOperator(ch)) addSymbol(string(1, ch), "Operator", lineNum);
            else if (isSymbol(ch)) addSymbol(string(1, ch), "Symbol", lineNum);
        } else {
            token += ch;
        }
    }

    if (!token.empty()) {
        if (keywords.count(token)) addSymbol(token, "Keyword", lineNum);
        else if (isIdentifier(token)) addSymbol(token, "Identifier", lineNum);
        else if (isInteger(token)) addSymbol(token, "Integer", lineNum);
        else if (isFloat(token)) addSymbol(token, "Float", lineNum);
        else cout << "Lexical error at line " << lineNum << ": " << token << "\n";
    }
}

int main() {
    ifstream file("sample.cpp");
    if (!file.is_open()) {
        cerr << "Could not open file\n";
        return 1;
    }

    string line;
    int lineNum = 1;
    while (getline(file, line)) {
        processLine(line, lineNum++);
    }

    cout << "\nSymbol Table:\n";
    cout << "Entry\tLexeme\t\tType\t\tDeclared\tUsed\n";
    for (const auto& s : symbolTable) {
        cout << s.entryNo << "\t" << s.lexeme << "\t\t" << s.tokenType
             << "\t\t" << s.lineDeclared << "\t\t" << s.lineUsed << '\n';
    }

    return 0;
}


ll1
#include <bits/stdc++.h>
using namespace std;

map<string, vector<vector<string>>> grammar;
map<string, set<string>> FIRST, FOLLOW;
map<pair<string, string>, vector<string>> parsingTable;

set<string> terminals = {"+", "*", "(", ")", "id", "$"};
set<string> nonTerminals = {"E", "E'", "T", "T'", "F"};
set<string> visitedFollow;

bool isTerminal(const string &s) {
    return terminals.count(s);
}

// Computation of FIRST
set<string> computeFIRST(const string &symbol) {
    if (FIRST.count(symbol)) return FIRST[symbol];

    set<string> result;
    if (isTerminal(symbol)) {
        result.insert(symbol);
        return FIRST[symbol] = result;
    }

    for (const auto &production : grammar[symbol]) {
        if (production[0] == "ε") {
            result.insert("ε");
            continue;
        }
        bool allEps = true;
        for (const string &sym : production) {
            set<string> temp = computeFIRST(sym);
            for (auto &x : temp)
                if (x != "ε") result.insert(x);
            if (!temp.count("ε")) { allEps = false; break; }
        }
        if (allEps) result.insert("ε");
    }
    return FIRST[symbol] = result;
}

// computation of FOLLOW
void computeFOLLOW(const string &symbol) {
    if (visitedFollow.count(symbol)) return;
    visitedFollow.insert(symbol);

    if (symbol == "E") FOLLOW[symbol].insert("$");

    for (auto &p : grammar) {
        const string &A = p.first;
        for (auto &prod : p.second) {
            for (int i = 0; i < prod.size(); i++) {
                if (prod[i] == symbol) {
                    bool last = (i == prod.size() - 1);
                    if (!last) {
                        set<string> firstNext = computeFIRST(prod[i + 1]);
                        for (auto &x : firstNext)
                            if (x != "ε") FOLLOW[symbol].insert(x);
                        if (firstNext.count("ε")) {
                            computeFOLLOW(A);
                            FOLLOW[symbol].insert(FOLLOW[A].begin(), FOLLOW[A].end());
                        }
                    } else {
                        computeFOLLOW(A);
                        FOLLOW[symbol].insert(FOLLOW[A].begin(), FOLLOW[A].end());
                    }
                }
            }
        }
    }
}

// creating the Parse Table
void buildParsingTable() {
    for (auto &p : grammar) {
        const string &A = p.first;
        for (auto &prod : p.second) {
            set<string> firstSet;
            if (prod[0] == "ε") {
                firstSet = FOLLOW[A];
            } else {
                bool allEps = true;
                for (const string &sym : prod) {
                    set<string> f = computeFIRST(sym);
                    for (auto &x : f)
                        if (x != "ε") firstSet.insert(x);
                    if (!f.count("ε")) { allEps = false; break; }
                }
                if (allEps) firstSet.insert("ε");
            }

            for (const string &term : firstSet) {
                if (term != "ε") {
                    parsingTable[{A, term}] = prod;
                } else {
                    for (const string &b : FOLLOW[A]) parsingTable[{A, b}] = prod;
                }
            }
        }
    }
}

// printing the parse table
void printParsingTable() {
    cout << "\nLL(1) Parsing Table:\n";
    vector<string> termList(terminals.begin(), terminals.end());
    sort(termList.begin(), termList.end());

    cout << setw(10) << "";
    for (auto &t : termList) cout << setw(15) << t;
    cout << "\n";

    for (auto &nt : nonTerminals) {
        cout << setw(10) << nt;
        for (auto &t : termList) {
            auto key = make_pair(nt, t);
            if (parsingTable.count(key)) {
                string prodStr = nt + " -> ";
                for (auto &sym : parsingTable[key]) prodStr += sym + " ";
                cout << setw(15) << prodStr;
            } else {
                cout << setw(15) << "-";
            }
        }
        cout << "\n";
    }
}

void parseInput(const string &input) {
    vector<string> stack = {"$", "E"};
    vector<string> tokens;
    stringstream ss(input);
    string tok;
    while (ss >> tok) tokens.push_back(tok);
    tokens.push_back("$");

    int ip = 0;
    cout << "\nParsing Steps:\n";
    cout << left << setw(25) << "Stack" << setw(25) << "Input" << "Action\n";
    cout << string(70, '-') << "\n";

    while (!stack.empty()) {
        string stackStr, inputStr;
        for (auto &s : stack) stackStr += s + " ";
        for (int i = ip; i < tokens.size(); i++) inputStr += tokens[i] + " ";

        string top = stack.back();
        string curr = tokens[ip];

        cout << left << setw(25) << stackStr << setw(25) << inputStr;

        if (top == curr) {
            cout << "Match " << curr << "\n";
            stack.pop_back();
            ip++;
        } else if (isTerminal(top)) {
            cout << "Error: unexpected token\n";
            return;
        } else if (parsingTable.count({top, curr})) {
            vector<string> prod = parsingTable[{top, curr}];
            cout << top << " -> ";
            for (auto &s : prod) cout << s << " ";
            cout << "\n";
            stack.pop_back();
            if (!(prod.size() == 1 && prod[0] == "ε")) {
                for (int i = prod.size() - 1; i >= 0; i--) stack.push_back(prod[i]);
            }
        } else {
            cout << "Error: no rule for (" << top << "," << curr << ")\n";
            return;
        }
    }
    cout << "String accepted!\n";
}

int main() {
    grammar["E"]  = {{"T", "E'"}};
    grammar["E'"] = {{"+", "T", "E'"}, {"ε"}};
    grammar["T"]  = {{"F", "T'"}};
    grammar["T'"] = {{"*", "F", "T'"}, {"ε"}};
    grammar["F"]  = {{"(", "E", ")"}, {"id"}};

    for (auto &nt : nonTerminals) computeFIRST(nt);
    visitedFollow.clear();
    for (auto &nt : nonTerminals) computeFOLLOW(nt);

    cout << "FIRST sets:\n";
    for (auto &p : FIRST) {
        cout << p.first << ": ";
        for (auto &x : p.second) cout << x << " ";
        cout << "\n";
    }

    cout << "\nFOLLOW sets:\n";
    for (auto &p : FOLLOW) {
        cout << p.first << ": ";
        for (auto &x : p.second) cout << x << " ";
        cout << "\n";
    }

    buildParsingTable();
    printParsingTable();

    // parseInput("id + id");
    // parseInput("id + id * id");
    parseInput("id + * id");

    return 0;
}


sr
#include <bits/stdc++.h>
using namespace std;

struct Rule {
    vector<string> rhs;
    string lhs;
};

vector<Rule> rules = {
    {{"E","+","T"}, "E"},
    {{"T","*","F"}, "T"},
    {{"(","E",")"}, "F"},
    {{"id"}, "F"},
    {{"F"}, "T"},
    {{"T"}, "E"}
};

bool reduce(vector<string> &st, string &action) {
    for (auto &r : rules) {
        if (st.size() >= r.rhs.size()) {
            bool match = true;
            for (int i = 0; i < (int)r.rhs.size(); i++) {
                if (st[st.size() - r.rhs.size() + i] != r.rhs[i]) {
                    match = false;
                    break;
                }
            }
            if (match) {
                for (int i = 0; i < (int)r.rhs.size(); i++) st.pop_back();
                // Push LHS
                st.push_back(r.lhs);
                action = "Reduce " + r.lhs + " ->";
                for (auto &s : r.rhs) action += " " + s;
                return true;
            }
        }
    }
    return false;
}

int main() {
    vector<string> tests = {"id+id", "id+id*id"};

    for (auto input : tests) {
        cout << "\nParsing: " << input << endl;
        vector<string> st;
        st.push_back("$"); 
        input += "$";      

        vector<string> tokens;
        for (int i = 0; i < (int)input.size();) {
            if (input.substr(i, 2) == "id") {
                tokens.push_back("id");
                i += 2;
            } else {
                tokens.push_back(string(1, input[i]));
                i++;
            }
        }

        int i = 0;
        while (true) {
            cout << "Stack: ";
            for (auto &s : st) cout << s;
            cout << "\tInput: ";
            for (int j = i; j < (int)tokens.size(); j++) cout << tokens[j];

            string action;

            if (st.size() >= 3 &&
                st[st.size()-3] == "E" &&
                st[st.size()-2] == "+" &&
                st[st.size()-1] == "T" &&
                i < tokens.size() && tokens[i] == "*")
            {
                st.push_back(tokens[i]);
                action = "Shift " + tokens[i];
                i++;
                cout << "\tAction: " << action << endl;
            }
            else if (reduce(st, action)) {
                cout << "\tAction: " << action << endl;
            }
            else if (i < (int)tokens.size()-1) { 
                st.push_back(tokens[i]);
                action = "Shift " + tokens[i];
                i++;
                cout << "\tAction: " << action << endl;
            }
            else {
                if (st.size() == 2 && st[0] == "$" && st[1] == "E") {
                    cout << "\tString Accepted!" << endl;
                } else {
                    cout << "\tError: Cannot parse string" << endl;
                }
                break;
            }
        }

    }
    return 0;
}






SHIFT REDUCE 
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <sstream>
#include <map>
#include <set>
#include <algorithm>
#include <tuple>
using namespace std;


using namespace std;


struct Action {
    string type; // "shift", "reduce", "accept", "error"
    int num;     // state number for shift, rule number for reduce
};


struct Rule {
    string lhs;
    vector<string> rhs;
};


vector<Rule> grammar = {
    {"S'", {"E"}},    // augmented grammar
    {"E", {"E", "+", "T"}},
    {"E", {"T"}},
    {"T", {"T", "*", "F"}},
    {"T", {"F"}},
    {"F", {"(", "E", ")"}},
    {"F", {"id"}}
};


map<pair<int, string>, Action> ACTION;
map<pair<int, string>, int> GOTO;
set<string> terminals = {"id", "+", "*", "(", ")", "$"};
set<string> nonterminals = {"E", "T", "F"};


struct Item {
    int rule;
    int dot;
    string lookahead;
};


bool operator<(const Item &a, const Item &b) {
    return tie(a.rule, a.dot, a.lookahead) < tie(b.rule, b.dot, b.lookahead);
}


bool isTerminal(const string &s) {
    return terminals.count(s);
}


set<string> FIRST(const vector<string> &symbols);


map<string, set<string>> firstMemo;
set<string> FIRST1(const string &sym) {
    if (firstMemo.count(sym)) return firstMemo[sym];
    set<string> res;
    if (isTerminal(sym)) {
        res.insert(sym);
    } else {
        for (auto &rule : grammar) {
            if (rule.lhs == sym) {
                auto tmp = FIRST(rule.rhs);
                res.insert(tmp.begin(), tmp.end());
            }
        }
    }
    return firstMemo[sym] = res;
}


set<string> FIRST(const vector<string> &symbols) {
    set<string> res;
    if (symbols.empty()) {
        res.insert("ε");
        return res;
    }
    for (auto &sym : symbols) {
        auto firstSym = FIRST1(sym);
        bool hasEps = firstSym.count("ε");
        firstSym.erase("ε");
        res.insert(firstSym.begin(), firstSym.end());
        if (!hasEps) return res;
    }
    res.insert("ε");
    return res;
}


map<string, set<string>> FOLLOW;
void computeFOLLOW() {
    FOLLOW["S'"].insert("$");
    bool changed = true;
    while (changed) {
        changed = false;
        for (auto &rule : grammar) {
            for (int i = 0; i < (int)rule.rhs.size(); i++) {
                string B = rule.rhs[i];
                if (!nonterminals.count(B)) continue;
                vector<string> beta(rule.rhs.begin() + i + 1, rule.rhs.end());
                auto firstBeta = FIRST(beta);
                size_t before = FOLLOW[B].size();
                for (auto &f : firstBeta) {
                    if (f != "ε") FOLLOW[B].insert(f);
                }
                if (firstBeta.count("ε") || beta.empty()) {
                    FOLLOW[B].insert(FOLLOW[rule.lhs].begin(), FOLLOW[rule.lhs].end());
                }
                if (FOLLOW[B].size() > before) changed = true;
            }
        }
    }
}


struct State {
    set<pair<int, int>> items; // (rule index, dot position)
};


vector<set<pair<int,int>>> states;
map<pair<int,string>, int> transitions;


set<pair<int,int>> closure(set<pair<int,int>> I) {
    bool changed = true;
    while (changed) {
        changed = false;
        set<pair<int,int>> newI = I;
        for (auto [ruleIdx, dot] : I) {
            auto &rule = grammar[ruleIdx];
            if (dot < (int)rule.rhs.size()) {
                string B = rule.rhs[dot];
                if (nonterminals.count(B)) {
                    for (int r = 0; r < (int)grammar.size(); r++) {
                        if (grammar[r].lhs == B) {
                            if (!newI.count({r,0})) {
                                newI.insert({r,0});
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
        I = newI;
    }
    return I;
}


set<pair<int,int>> goTo(set<pair<int,int>> I, string X) {
    set<pair<int,int>> J;
    for (auto [ruleIdx, dot] : I) {
        auto &rule = grammar[ruleIdx];
        if (dot < (int)rule.rhs.size() && rule.rhs[dot] == X) {
            J.insert({ruleIdx, dot+1});
        }
    }
    return closure(J);
}


int getStateIndex(set<pair<int,int>> I) {
    for (int i=0;i<(int)states.size();i++)
        if (states[i] == I) return i;
    return -1;
}


void buildLR0() {
    set<pair<int,int>> start = closure({{0,0}});
    states.push_back(start);
    bool changed = true;
    while (changed) {
        changed = false;
        for (int i=0;i<(int)states.size();i++) {
            for (auto X : terminals) {
                auto next = goTo(states[i], X);
                if (!next.empty()) {
                    int idx = getStateIndex(next);
                    if (idx == -1) {
                        idx = states.size();
                        states.push_back(next);
                        changed = true;
                    }
                    transitions[{i,X}] = idx;
                }
            }
            for (auto X : nonterminals) {
                auto next = goTo(states[i], X);
                if (!next.empty()) {
                    int idx = getStateIndex(next);
                    if (idx == -1) {
                        idx = states.size();
                        states.push_back(next);
                        changed = true;
                    }
                    transitions[{i,X}] = idx;
                }
            }
        }
    }
}


void buildParsingTable() {
    computeFOLLOW();
    buildLR0();
    for (int i=0;i<(int)states.size();i++) {
        for (auto [ruleIdx, dot] : states[i]) {
            auto &rule = grammar[ruleIdx];
            if (dot < (int)rule.rhs.size()) {
                string a = rule.rhs[dot];
                if (isTerminal(a)) {
                    ACTION[{i,a}] = {"shift", transitions[{i,a}]};
                }
            } else {
                if (ruleIdx == 0) {
                    ACTION[{i,"$"}] = {"accept", -1};
                } else {
                    for (auto a : FOLLOW[rule.lhs]) {
                        ACTION[{i,a}] = {"reduce", ruleIdx};
                    }
                }
            }
        }
        for (auto A : nonterminals) {
            if (transitions.count({i,A})) {
                GOTO[{i,A}] = transitions[{i,A}];
            }
        }
    }
}


void parseInput(vector<string> tokens) {
    tokens.push_back("$");
    vector<int> stateStack = {0};
    vector<string> symbolStack = {"$"};
    int ip = 0;
    cout << "+------------------------------+------------------------------+------------------------------+\n";
    cout << "| Stack                        | Input                        | Action                       |\n";
    cout << "+------------------------------+------------------------------+------------------------------+\n";
    while (true) {
        int s = stateStack.back();
        string a = tokens[ip];
        Action act = ACTION.count({s,a}) ? ACTION[{s,a}] : Action{"error",-1};


        // Print step
        string stackStr, inputStr;
        for (auto &sym : symbolStack) stackStr += sym + " ";
        for (int i=ip;i<(int)tokens.size();i++) inputStr += tokens[i] + " ";
        cout << "| " << setw(28) << left << stackStr
             << "| " << setw(28) << left << inputStr;
        
        if (act.type == "shift") {
            cout << "| Shift " << a << " to state " << act.num << "       |\n";
            symbolStack.push_back(a);
            stateStack.push_back(act.num);
            ip++;
        } else if (act.type == "reduce") {
            auto &rule = grammar[act.num];
            cout << "| Reduce by " << rule.lhs << " → ";
            for (auto &x : rule.rhs) cout << x;
            cout << "         |\n";
            for (int j=0;j<(int)rule.rhs.size();j++) {
                symbolStack.pop_back();
                stateStack.pop_back();
            }
            symbolStack.push_back(rule.lhs);
            int t = stateStack.back();
            stateStack.push_back(GOTO[{t, rule.lhs}]);
        } else if (act.type == "accept") {
            cout << "| Accept                       |\n";
            break;
        } else {
            cout << "| Error: string not accepted.  |\n";
            break;
        }
    }
    cout << "+------------------------------+------------------------------+------------------------------+\n";
}


int main() {
    buildParsingTable();
    vector<string> input;
    string st;
    while((cin>>st))input.push_back(st);
    
    parseInput(input);
}


lr0
#include <bits/stdc++.h>
using namespace std;

struct Prod {
    string lhs;
    vector<string> rhs;
    string to_string() const {
        string s = lhs + " ->";
        for (auto &r: rhs) s += " " + r;
        return s;
    }
};

struct Item {
    int prod;       
    int dot;         
    bool operator<(Item const& o) const {
        if(prod!=o.prod) return prod<o.prod;
        return dot<o.dot;
    }
    bool operator==(Item const& o) const { return prod==o.prod && dot==o.dot; }
};

string join(const vector<string>& v) {
    string s;
    for (size_t i=0;i<v.size();++i) {
        if(i) s += " ";
        s += v[i];
    }
    return s;
}


vector<Prod> prods;
set<string> terminals, nonterminals;
string START = "S'";

vector<Item> closure(const vector<Item>& items) {
    set<pair<int,int>> added;
    queue<Item> q;
    for (auto &it: items) { q.push(it); added.insert({it.prod,it.dot}); }

    while(!q.empty()) {
        Item it = q.front(); q.pop();
        Prod p = prods[it.prod];
        if (it.dot < (int)p.rhs.size()) {
            string B = p.rhs[it.dot];
            if (nonterminals.count(B)) {
                for (int i=0;i<(int)prods.size();++i) {
                    if (prods[i].lhs == B) {
                        if (!added.count({i,0})) {
                            added.insert({i,0});
                            q.push({i,0});
                        }
                    }
                }
            }
        }
    }
    vector<Item> out;
    for (auto &pr: added) out.push_back({pr.first, pr.second});
    sort(out.begin(), out.end());
    return out;
}

vector<Item> go_to(const vector<Item>& I, const string& X) {
    vector<Item> moved;
    for (auto &it: I) {
        Prod p = prods[it.prod];
        if (it.dot < (int)p.rhs.size() && p.rhs[it.dot] == X) {
            moved.push_back({it.prod, it.dot+1});
        }
    }
    return closure(moved);
}

string item_to_str(const Item &it) {
    Prod p = prods[it.prod];
    string s = p.lhs + " ->";
    for (int i=0;i<= (int)p.rhs.size(); ++i) {
        if (i==it.dot) s += " .";
        if (i < (int)p.rhs.size()) s += " " + p.rhs[i];
    }
    return s;
}

int main(){
    prods = {
        {"S'", {"S"}},
        {"S", {"C","C"}},
        {"C", {"c","C"}},
        {"C", {"d"}}
    };
    nonterminals = {"S'", "S", "C"};
    terminals = {"c","d","$"}; // $ is EOF

    vector<vector<Item>> states;
    map<vector<Item>, int> state_id;

    vector<Item> start_items = closure({{0,0}}); // S' -> . S
    states.push_back(start_items);
    state_id[start_items] = 0;

    queue<int> q;
    q.push(0);

    vector<string> symbols;
    for (auto &t : terminals) if (t != "$") symbols.push_back(t);
    for (auto &nt: nonterminals) symbols.push_back(nt);

    map<pair<int,string>, int> transitions; 

    while(!q.empty()) {
        int s = q.front(); q.pop();
        auto I = states[s];

        set<string> Xs;
        for (auto &it: I) {
            Prod p = prods[it.prod];
            if (it.dot < (int)p.rhs.size()) Xs.insert(p.rhs[it.dot]);
        }
        for (auto &X: Xs) {
            vector<Item> gotoI = go_to(I, X);
            if (gotoI.empty()) continue;
            if (!state_id.count(gotoI)) {
                int nid = (int)states.size();
                states.push_back(gotoI);
                state_id[gotoI] = nid;
                q.push(nid);
            }
            transitions[{s,X}] = state_id[gotoI];
        }
    }

    cout << "LR0:\n";
    for (int i=0;i<(int)states.size();++i) {
        cout << "State " << i << ":\n";
        for (auto &it: states[i]) cout << "  " << item_to_str(it) << "\n";
        cout << "\n";
    }

    cout << "Transitions\n";
    for (auto &tr: transitions) {
        cout << "  (" << tr.first.first << ", " << tr.first.second << ") -> " << tr.second << "\n";
    }
    cout << "\n";

    map<pair<int,string>, string> ACTION;
    map<pair<int,string>, int> GOTO;

    for (int i=0;i<(int)states.size();++i) {
        for (auto &it: states[i]) {
            Prod p = prods[it.prod];
            if (it.dot < (int)p.rhs.size()) {
                string a = p.rhs[it.dot];
                if (terminals.count(a)) {
                    auto key = make_pair(i,a);
                    int j = transitions[{i,a}];
                    ACTION[key] = "s" + to_string(j);
                } else if (nonterminals.count(a)) {
                    // goto table
                    int j = transitions[{i,a}];
                    GOTO[{i,a}] = j;
                }
            } else {
                if (p.lhs == START) {
                    // S' -> S .
                    ACTION[{i,"$"}] = "acc";
                } else {
                    for (auto &a: terminals) {
                        auto key = make_pair(i,a);
                        string r = "r" + to_string(it.prod);
                        if (ACTION.count(key) && ACTION[key] != r) {
                            ACTION[key] = ACTION[key] + " | " + r; 
                        } else {
                            ACTION[key] = r;
                        }
                    }
                }
            }
        }
    }

    cout << "ACTION table (terminals = c, d, $):\n";
    cout << setw(6) << "state" << setw(8) << "c" << setw(8) << "d" << setw(8) << "$" << "\n";
    for (int i=0;i<(int)states.size();++i) {
        cout << setw(6) << i;
        for (auto t : vector<string>{"c","d","$"}) {
            string a = ACTION.count({i,t}) ? ACTION[{i,t}] : "";
            cout << setw(8) << a;
        }
        cout << "\n";
    }
    cout << "\n";

    cout << "GOTO table (nonterminals = S, C):\n";
    cout << setw(6) << "state" << setw(8) << "S" << setw(8) << "C" << "\n";
    for (int i=0;i<(int)states.size();++i) {
        cout << setw(6) << i;
        for (auto nt: vector<string>{"S","C"}) {
            string g = GOTO.count({i,nt}) ? to_string(GOTO[{i,nt}]) : "";
            cout << setw(8) << g;
        }
        cout << "\n";
    }
    cout << "\n";

    vector<string> input = {"c","c","d","d","$"};
    vector<int> stateStack;
    vector<string> symStack;
    stateStack.push_back(0); // start state

    cout << "Parsing trace for input: ccdd$\n";
    cout << left << setw(30) << "Stack (states/syms)" << setw(20) << "Input" << "Action\n";

    auto print_stack = [&](){
        string s;
        for (size_t i=0;i<stateStack.size(); ++i) {
            s += to_string(stateStack[i]);
            if (i < symStack.size()) s += " / " + symStack[i];
            if (i+1 < stateStack.size()) s += "  ";
        }
        return s;
    };

    int ip = 0;
    while (true) {
        string curInput;
        for (int k=ip;k<(int)input.size();++k) {
            if (k>ip) curInput += " ";
            curInput += input[k];
        }
        string curStackStr = print_stack();
        int s = stateStack.back();
        string a = input[ip];
        string action = ACTION.count({s,a}) ? ACTION[{s,a}] : "";

        cout << setw(30) << curStackStr << setw(20) << curInput;

        if (action.empty()) {
            cout << "ERROR\n";
            break;
        }
        if (action.rfind("s",0) == 0) {
            // shift
            int ns = stoi(action.substr(1));
            cout << "shift, go to " << ns << "\n";
            symStack.push_back(a);
            stateStack.push_back(ns);
            ip++;
        } else if (action.rfind("r",0) == 0) {
            int pidx = stoi(action.substr(1));
            Prod rp = prods[pidx];
            cout << "reduce by (" << pidx << ") " << rp.to_string() << "\n";
            // pop |rhs| symbols and states
            int k = rp.rhs.size();
            for (int i=0;i<k;i++) {
                if (!symStack.empty()) symStack.pop_back();
                if (!stateStack.empty()) stateStack.pop_back();
            }
            // push LHS symbol
            symStack.push_back(rp.lhs);
            // goto from new top state on rp.lhs
            int topState = stateStack.back();
            if (GOTO.count({topState, rp.lhs})) {
                int g = GOTO[{topState, rp.lhs}];
                stateStack.push_back(g);
            } else {
                cout << "GOTO error\n";
                break;
            }
        } else if (action == "acc") {
            cout << "ACCEPT\n";
            break;
        } else {
            cout << action << " (conflict or multiple actions)\n";
            break;
        }
    }

    return 0;
}


3AC
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <cctype>
#include <map>
#include <iomanip>
#include <algorithm>
#include <stdexcept>
#include <regex>
using namespace std;


// --- Data Structures ---
struct Quad {
    string op;
    string arg1;
    string arg2;
    string result; // Also used for labels/jump targets
};


// --- Global counters ---
int labelCount = 1; // For generating labels
int tempCount  = 1; // For unique temporaries


string newLabel() { return "L" + to_string(labelCount++); }
string newTemp()  { return "t" + to_string(tempCount++); }


// --- Utility to parse simple binary conditions like "a<b" or "c!=d" ---
void parseCondition(const string &cond, string &arg1, string &op, string &arg2) {
    size_t pos = string::npos;
    string ops[] = {"<=", ">=", "==", "!=", "<", ">"};


    for (auto &o : ops) {
        pos = cond.find(o);
        if (pos != string::npos) {
            arg1 = cond.substr(0, pos);
            op   = o;
            arg2 = cond.substr(pos + o.length());
            return;
        }
    }
    throw runtime_error("Unsupported boolean operator in: " + cond);
}


// --- Core Arithmetic Logic ---
void applyOperation(stack<string>& values, stack<char>& ops, vector<Quad>& quads) {
    if (values.size() < 2 || ops.empty())
        throw runtime_error("Syntax error: Invalid expression format.");


    char op = ops.top(); ops.pop();
    string arg2 = values.top(); values.pop();
    string arg1 = values.top(); values.pop();
    string result = newTemp(); // generate unique temporary


    quads.push_back({string(1, op), arg1, arg2, result});
    values.push(result);
}


int getPrecedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}


vector<Quad> generateArithmeticCode(const string& expression) {
    stack<string> values;
    stack<char> ops;
    vector<Quad> quads;


    size_t i = 0;
    while (i < expression.size()) {
        if (isalnum(expression[i])) {
            // Read full variable or number
            string var;
            while (i < expression.size() && (isalnum(expression[i]) || expression[i]=='_'))
                var += expression[i++];
            values.push(var);
        }
        else if (expression[i] == '(') {
            ops.push(expression[i]);
            i++;
        }
        else if (expression[i] == ')') {
            while (!ops.empty() && ops.top() != '(')
                applyOperation(values, ops, quads);


            if (ops.empty()) throw runtime_error("Mismatched parentheses.");
            ops.pop();
            i++;
        }
        else { // operator
            while (!ops.empty() && ops.top() != '(' && getPrecedence(ops.top()) >= getPrecedence(expression[i]))
                applyOperation(values, ops, quads);
            ops.push(expression[i]);
            i++;
        }
    }


    while (!ops.empty()) {
        if (ops.top() == '(') throw runtime_error("Mismatched parentheses.");
        applyOperation(values, ops, quads);
    }
    return quads;
}


// --- Printing ---
void printTAC(const vector<Quad>& quads) {
    cout << "\n## Three-Address Code (TAC)\n\n";
    int line = 100;


    for (const auto& q : quads) {
        cout << line++ << ": ";
        if (q.op == "label")        cout << q.arg1 << ":" << endl;
        else if (q.op == "assign")  cout << q.arg1 << endl;
        else if (q.op == "goto")    cout << "goto " << q.arg1 << endl;
        else if (q.op.find("if") != string::npos) cout << q.op << " " << q.arg1 << " goto " << q.result << endl;
        else if (q.op == "=")       cout << q.result << " = " << q.arg1 << endl;
        else                        cout << q.result << " = " << q.arg1 << " " << q.op << " " << q.arg2 << endl;
    }
}


void printQuadsTriplesTemps(const vector<Quad>& quads) {
    // Quadruples
    cout << "\n## Quadruples (op, arg1, arg2, result)\n\n";
    cout << left << setw(12) << "No."
         << setw(14) << "Operator"
         << setw(14) << "Arg1"
         << setw(14) << "Arg2"
         << setw(14) << "Result" << "\n";
    cout << string(68, '-') << "\n";


    int lineNo = 100;
    for (const auto& q : quads) {
        cout << left << setw(12) << lineNo++
             << setw(14) << q.op
             << setw(14) << (q.arg1.empty() ? "-" : q.arg1)
             << setw(14) << (q.arg2.empty() ? "-" : q.arg2)
             << setw(14) << (q.result.empty() ? "-" : q.result)
             << "\n";
    }


    // Triples
    cout << "\n## Triples (index: op, arg1, arg2)\n\n";
    cout << left << setw(8) << "Idx"
         << setw(14) << "Operator"
         << setw(18) << "Arg1"
         << setw(18) << "Arg2" << "\n";
    cout << string(58, '-') << "\n";


    map<string,string> result_to_index;
    for (int i = 0; i < (int)quads.size(); ++i) {
        const auto &q = quads[i];
        string arg1_ref = q.arg1;
        string arg2_ref = q.arg2;


        if (!arg1_ref.empty() && result_to_index.count(arg1_ref)) arg1_ref = result_to_index[arg1_ref];
        if (!arg2_ref.empty() && result_to_index.count(arg2_ref)) arg2_ref = result_to_index[arg2_ref];


        string idxStr = "(" + to_string(i) + ")";
        cout << left << setw(8) << idxStr
             << setw(14) << q.op
             << setw(18) << (arg1_ref.empty() ? "-" : arg1_ref)
             << setw(18) << (arg2_ref.empty() ? "-" : arg2_ref)
             << "\n";


        if (!q.result.empty()) result_to_index[q.result] = idxStr;
    }


    // Temporaries
    cout << "\n## Temporaries created (temp -> triple index if mapped)\n\n";
    regex r("^t[0-9]+$");
    for (const auto &q : quads) {
        if (!q.result.empty() && regex_match(q.result, r)) {
            cout << q.result << " -> " << result_to_index[q.result] << "\n";
        }
    }
}


// --- Handlers ---
void handleArithmetic(const string& expression) {
    vector<Quad> quads = generateArithmeticCode(expression);
    cout << "\n--- Generated Intermediate Code for Arithmetic Expression ---\n";
    printTAC(quads);
    printQuadsTriplesTemps(quads);
}


void handleBoolean(const string& expression) {
    regex pattern(R"(if\s*\(\s*\((.+?)\)\s*and\s*\((.+?)\)\s*\)\s*then\s*(.+?)\s*else\s*(.+))");
    smatch matches;


    if (regex_match(expression, matches, pattern) && matches.size() == 5) {
        string cond1     = matches[1].str();
        string cond2     = matches[2].str();
        string then_stmt = matches[3].str();
        string else_stmt = matches[4].str();


        string L_else = newLabel();
        string L_end  = newLabel();
        vector<Quad> quads;


        // Parse each condition
        string arg1, arg2, op;
        parseCondition(cond1, arg1, op, arg2);
        string t1 = newTemp();
        quads.push_back({op, arg1, arg2, t1});


        parseCondition(cond2, arg1, op, arg2);
        string t2 = newTemp();
        quads.push_back({op, arg1, arg2, t2});


        // Conditional jumps
        quads.push_back({ "if_false", t1, "", L_else });
        quads.push_back({ "if_false", t2, "", L_else });
        quads.push_back({ "assign", then_stmt, "", "" });
        quads.push_back({ "goto", L_end, "", "" });
        quads.push_back({ "label", L_else, "", "" });
        quads.push_back({ "assign", else_stmt, "", "" });
        quads.push_back({ "label", L_end, "", "" });


        cout << "\n--- Generated Intermediate Code for Boolean Expression ---\n";
        printTAC(quads);
        printQuadsTriplesTemps(quads);
    } 
    else {
        cout << "Boolean expression format not recognized.\n";
    }
}


void handleWhile(const string& expression) {
    regex pattern(R"(while\s*\((.+?)\)\s*\{\s*(.+)\s*\})");
    smatch matches;


    if (regex_match(expression, matches, pattern) && matches.size() == 3) {
        string condition = matches[1].str();
        string body_str  = matches[2].str();


        string L_begin = newLabel();
        string L_body  = newLabel();
        string L_end   = newLabel();


        vector<Quad> quads;
        quads.push_back({ "label", L_begin, "", "" });
        quads.push_back({ "if_goto", condition, "", L_body });
        quads.push_back({ "goto", L_end, "", "" });
        quads.push_back({ "label", L_body, "", "" });


        regex body_pattern(R"((\w+)\s*=\s*(.+?);)");
        auto body_begin = sregex_iterator(body_str.begin(), body_str.end(), body_pattern);
        auto body_end   = sregex_iterator();


        for (sregex_iterator i = body_begin; i != body_end; ++i) {
            smatch body_match = *i;
            string dest = body_match[1].str();
            string expr = body_match[2].str();


            vector<Quad> body_quads = generateArithmeticCode(expr);
            for (const auto& bq : body_quads) quads.push_back(bq);


            if (!body_quads.empty())
                quads.push_back({ "=", body_quads.back().result, "", dest });
            else
                quads.push_back({ "=", expr, "", dest });
        }


        quads.push_back({ "goto", L_begin, "", "" });
        quads.push_back({ "label", L_end, "", "" });


        cout << "\n--- Generated Intermediate Code for While Loop ---\n";
        printTAC(quads);
        printQuadsTriplesTemps(quads);
    } 
    else {
        cout << "While loop format not recognized.\n";
    }
}


// --- Main Driver ---
int main() {
    string expression;
    getline(cin, expression);


    string sanitized_expr;
    for (char c : expression) if (!isspace(c)) sanitized_expr += c;


    try {
        if (sanitized_expr.rfind("if", 0) == 0)        handleBoolean(sanitized_expr);
        else if (sanitized_expr.rfind("while", 0) == 0) handleWhile(sanitized_expr);
        else                                           handleArithmetic(sanitized_expr);
    } 
    catch (const exception& e) {
        return 1;
    }
    return 0;
}






Airthmatic
#include <bits/stdc++.h>
using namespace std;

int tempCount = 0;
string newTemp() { return "t" + to_string(tempCount++); }

struct Quadruple { string op, arg1, arg2, result; };
struct Triple { string op, arg1, arg2; };
struct TAC { string code; };

vector<Quadruple> quads;
vector<Triple> triples;
vector<TAC> tac;

// Operator precedence
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// Convert infix to postfix
string infixToPostfix(string expr) {
    stack<char> st;
    string postfix;
    for (char c : expr) {
        if (isspace(c)) continue;
        if (isalnum(c)) postfix += c, postfix += ' ';
        else if (c == '(') st.push(c);
        else if (c == ')') {
            while (!st.empty() && st.top() != '(')
                postfix += st.top(), postfix += ' ', st.pop();
            if (!st.empty()) st.pop();
        } else {
            while (!st.empty() && precedence(st.top()) >= precedence(c))
                postfix += st.top(), postfix += ' ', st.pop();
            st.push(c);
        }
    }
    while (!st.empty()) postfix += st.top(), postfix += ' ', st.pop();
    return postfix;
}

// Generate code for postfix
void generateCode(string postfix) {
    stack<string> st;
    stringstream ss(postfix);
    string token;

    while (ss >> token) {
        if (isalnum(token[0])) st.push(token);
        else {
            string b = st.top(); st.pop();
            string a = st.top(); st.pop();
            string t = newTemp();

            tac.push_back({t + " = " + a + " " + token + " " + b});
            quads.push_back({token, a, b, t});
            triples.push_back({token, a, b});
            st.push(t);
        }
    }
}

void printAll() {
    cout << "\n--- THREE ADDRESS CODE ---\n";
    for (auto &t : tac) cout << t.code << endl;

    cout << "\n--- QUADRUPLES ---\nOp\tArg1\tArg2\tResult\n";
    for (auto &q : quads) cout << q.op << "\t" << q.arg1 << "\t" << q.arg2 << "\t" << q.result << endl;

    cout << "\n--- TRIPLES ---\nIdx\tOp\tArg1\tArg2\n";
    for (int i = 0; i < triples.size(); i++)
        cout << i << "\t" << triples[i].op << "\t" << triples[i].arg1 << "\t" << triples[i].arg2 << endl;
}

int main() {
    string expr = "(A+B)*(C-D)/(E+F)";
    cout << "Input Expression: " << expr << endl;
    string postfix = infixToPostfix(expr);
    cout << "Postfix: " << postfix << endl;

    generateCode(postfix);
    printAll();
}









if-else
#include <bits/stdc++.h>
using namespace std;

int tempCount = 0, labelCount = 0;
string newTemp() { return "t" + to_string(tempCount++); }
string newLabel() { return "L" + to_string(labelCount++); }

struct Quadruple { string op, arg1, arg2, result; };
struct Triple { string op, arg1, arg2; };
struct TAC { string code; };

vector<Quadruple> quads;
vector<Triple> triples;
vector<TAC> tac;

void generateIfElse() {
    string t0 = newTemp(); quads.push_back({"<","a","b",t0}); tac.push_back({t0 + " = a < b"}); triples.push_back({"<","a","b"});
    string t1 = newTemp(); quads.push_back({"!=","c","d",t1}); tac.push_back({t1 + " = c != d"}); triples.push_back({"!=","c","d"});
    string t2 = newTemp(); quads.push_back({"&&",t0,t1,t2}); tac.push_back({t2 + " = " + t0 + " && " + t1}); triples.push_back({"&&",t0,t1});

    string L1 = newLabel(), L2 = newLabel();
    tac.push_back({"if " + t2 + " goto " + L1});
    tac.push_back({"x = 0"});
    tac.push_back({"goto " + L2});
    tac.push_back({L1 + ": x = 1"});
    tac.push_back({L2 + ":"});
}

void printAll() {
    cout << "\n--- THREE ADDRESS CODE ---\n";
    for (auto &t : tac) cout << t.code << endl;

    cout << "\n--- QUADRUPLES ---\nOp\tArg1\tArg2\tResult\n";
    for (auto &q : quads) cout << q.op << "\t" << q.arg1 << "\t" << q.arg2 << "\t" << q.result << endl;

    cout << "\n--- TRIPLES ---\nIdx\tOp\tArg1\tArg2\n";
    for (int i = 0; i < triples.size(); i++)
        cout << i << "\t" << triples[i].op << "\t" << triples[i].arg1 << "\t" << triples[i].arg2 << endl;
}

int main() {
    cout << "Generating code for: if ((a<b) && (c!=d)) then x=1 else x=0\n";
    generateIfElse();
    printAll();
}






while
#include <bits/stdc++.h>
using namespace std;

int tempCount = 0, labelCount = 0;
string newTemp() { return "t" + to_string(tempCount++); }
string newLabel() { return "L" + to_string(labelCount++); }

struct Quadruple { string op, arg1, arg2, result; };
struct Triple { string op, arg1, arg2; };
struct TAC { string code; };

vector<Quadruple> quads;
vector<Triple> triples;
vector<TAC> tac;

void generateWhile() {
    string L1 = newLabel(), L2 = newLabel(), L3 = newLabel();
    string t0 = newTemp(), t1 = newTemp(), t2 = newTemp();

    tac.push_back({L1 + ":"});
    tac.push_back({t0 + " = i < n"});
    tac.push_back({"if " + t0 + " goto " + L2});
    tac.push_back({"goto " + L3});
    tac.push_back({L2 + ":"});
    tac.push_back({t1 + " = sum + i"});
    tac.push_back({"sum = " + t1});
    tac.push_back({t2 + " = i + 1"});
    tac.push_back({"i = " + t2});
    tac.push_back({"goto " + L1});
    tac.push_back({L3 + ":"});

    quads.push_back({"<","i","n",t0});
    quads.push_back({"+","sum","i",t1});
    quads.push_back({"=",t1,"","sum"});
    quads.push_back({"+","i","1",t2});
    quads.push_back({"=",t2,"","i"});

    triples.push_back({"<","i","n"});
    triples.push_back({"+","sum","i"});
    triples.push_back({"=","(1)","sum"});
    triples.push_back({"+","i","1"});
    triples.push_back({"=","(3)","i"});
}

void printAll() {
    cout << "\n--- THREE ADDRESS CODE ---\n";
    for (auto &t : tac) cout << t.code << endl;

    cout << "\n--- QUADRUPLES ---\nOp\tArg1\tArg2\tResult\n";
    for (auto &q : quads) cout << q.op << "\t" << q.arg1 << "\t" << q.arg2 << "\t" << q.result << endl;

    cout << "\n--- TRIPLES ---\nIdx\tOp\tArg1\tArg2\n";
    for (int i = 0; i < triples.size(); i++)
        cout << i << "\t" << triples[i].op << "\t" << triples[i].arg1 << "\t" << triples[i].arg2 << endl;
}

int main() {
    cout << "Generating code for: while (i < n) { sum = sum + i; i = i + 1; }\n";
    generateWhile();
    printAll();
}

